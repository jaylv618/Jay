<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>综合设备调试工具 - HID/Modbus/DFU</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2d388a, #4a4b8c);
            color: #f0f0f0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        
        .tab-container {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
        }
        
        .tab {
            padding: 12px 25px;
            cursor: pointer;
            background: rgba(30, 35, 80, 0.5);
            border-radius: 8px 8px 0 0;
            margin-right: 5px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: none;
            white-space: nowrap;
        }
        
        .tab:hover {
            background: rgba(60, 65, 120, 0.7);
        }
        
        .tab.active {
            background: rgba(78, 84, 200, 0.8);
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }
        
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(30, 35, 80, 0.7);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel-title {
            display: flex;
            align-items: center;
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4e54c8;
        }
        
        .panel-title i {
            margin-right: 10px;
            color: #6c7bff;
        }
        
        .device-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .info-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }
        
        .info-label {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-size: 1.1rem;
            font-weight: 500;
            word-break: break-all;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 24px;
            background: linear-gradient(to right, #4e54c8, #6c7bff);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(78, 84, 200, 0.4);
            margin: 5px;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(78, 84, 200, 0.6);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .btn i {
            margin-right: 8px;
        }
        
        .btn-disconnect {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
        }
        
        .btn-serial {
            background: linear-gradient(to right, #00b09b, #96c93d);
        }
        
        .btn-dfu {
            background: linear-gradient(to right, #8e2de2, #4a00e0);
        }
        
        .btn:disabled {
            background: #6c757d !important;
            color: #adb5bd !important;
            cursor: not-allowed !important;
            opacity: 0.6;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .btn:disabled:hover {
            transform: none !important;
            box-shadow: none !important;
        }
        
        .btn-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
            color: white;
            font-size: 1rem;
        }
        
        textarea {
            height: 150px;
            font-family: monospace;
            resize: vertical;
        }
        
        .hex-input {
            font-family: monospace;
        }
        
        .command-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .history-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-family: monospace;
            font-size: 0.9rem;
            display: flex;
        }
        
        .history-time {
            opacity: 0.7;
            margin-right: 15px;
            min-width: 70px;
        }
        
        .history-data {
            word-break: break-all;
        }
        
        .received-data {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .status {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-radius: 50px;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 20px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .status-connected {
            background: #4caf50;
            box-shadow: 0 0 10px #4caf50;
        }
        
        .status-disconnected {
            background: #f44336;
        }
        
        .status-pending {
            background: #ff9800;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            background: rgba(40, 40, 40, 0.9);
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.4s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification-success {
            border-left: 5px solid #4caf50;
        }
        
        .notification-error {
            border-left: 5px solid #f44336;
        }
        
        .notification-warning {
            border-left: 5px solid #ff9800;
        }
        
        .notification-info {
            border-left: 5px solid #2196F3;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        .code-block {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .troubleshooting {
            background: rgba(200, 50, 50, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border-left: 3px solid #ff5252;
        }
        
        .troubleshooting h3 {
            color: #ff9e9e;
            margin-bottom: 10px;
        }
        
        .troubleshooting ul {
            padding-left: 20px;
        }
        
        .troubleshooting li {
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .error-details {
            background: rgba(255, 82, 82, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.85rem;
        }
        
        .modbus-command {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .modbus-command-title {
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modbus-command-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .modbus-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .modbus-response {
            background: rgba(0, 100, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
        }
        
        .serial-port-list {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }
        
        .serial-port-item {
            padding: 8px;
            cursor: pointer;
            border-radius: 5px;
            margin-bottom: 5px;
            transition: background 0.2s;
        }
        
        .serial-port-item:hover {
            background: rgba(78, 84, 200, 0.3);
        }
        
        .serial-port-item.active {
            background: rgba(78, 84, 200, 0.5);
            font-weight: 500;
        }
        
        .dfu-progress-container {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }
        
        .dfu-progress-bar {
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .dfu-progress {
            height: 100%;
            background: linear-gradient(to right, #00b09b, #96c93d);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: white;
        }
        
        .dfu-file-info {
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        .dfu-flash-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .dfu-command {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
        }
        
        .dfu-memory-info {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }
        
        .dfu-memory-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .dfu-memory-name {
            font-weight: 500;
        }
        
        .dfu-memory-value {
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-tools"></i> 综合设备调试工具</h1>
            <p class="subtitle">USB HID / 串口Modbus / DFU固件升级 - 基于WebHID, WebSerial和WebUSB API</p>
        </header>
        
        <div class="tab-container">
            <div class="tab active" data-tab="hid">USB HID调试</div>
            <div class="tab" data-tab="modbus">串口Modbus调试</div>
            <div class="tab" data-tab="dfu">DFU固件升级</div>
        </div>
        
        <!-- HID调试面板 -->
        <div id="hid-tab" class="tab-content active">
            <div class="content">
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-microchip"></i> 设备连接与控制</h2>
                    
                    <div class="device-info">
                        <div class="info-item">
                            <div class="info-label">连接状态</div>
                            <div class="info-value" id="connection-status">未连接</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">设备名称</div>
                            <div class="info-value" id="device-name">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">厂商ID (VID)</div>
                            <div class="info-value" id="vendor-id">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">产品ID (PID)</div>
                            <div class="info-value" id="product-id">-</div>
                        </div>
                    </div>
                    
                    <div class="btn-container">
                        <button id="connect-btn" class="btn"><i class="fas fa-plug"></i> 连接设备</button>
                        <button id="disconnect-btn" class="btn btn-disconnect"><i class="fas fa-unplug"></i> 断开连接</button>
                        <button id="refresh-btn" class="btn"><i class="fas fa-sync-alt"></i> 刷新设备</button>
                    </div>
                    
                    <div class="status">
                        <div class="status-dot" id="status-dot"></div>
                        <span id="status-text">准备连接设备...</span>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-cogs"></i> 通信配置</h2>
                    
                    <div class="config-grid">
                        <div class="form-group">
                            <label for="report-id">报告ID</label>
                            <input type="number" id="report-id" min="0" max="255" value="1">
                        </div>
                        
                        <div class="form-group">
                            <label for="data-size">报告长度 (字节)</label>
                            <input type="number" id="data-size" min="1" max="64" value="8">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="command-data">命令数据 (十六进制, 空格分隔)</label>
                        <input type="text" id="command-data" class="hex-input" value="AA BB CC DD EE FF 00 11">
                        <p style="font-size: 0.8rem; opacity: 0.7; margin-top: 5px;">提示：数据长度必须与报告长度一致</p>
                    </div>
                    
                    <div class="btn-container">
                        <button id="send-btn" class="btn"><i class="fas fa-paper-plane"></i> 发送命令</button>
                        <button id="clear-btn" class="btn"><i class="fas fa-trash"></i> 清除记录</button>
                        <button id="test-btn" class="btn"><i class="fas fa-vial"></i> 测试发送</button>
                    </div>
                    
                    <div class="command-history">
                        <h3>命令历史</h3>
                        <div id="history-container"></div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-code"></i> 报告描述符</h2>
                    <textarea id="report-descriptor" placeholder="在此处粘贴您的报告描述符...">0x06, 0x00, 0xFF,  // Usage Page (Vendor Defined 0xFF00)
                        0x09, 0x01,        // Usage (Vendor 1)
                        0xA1, 0x01,        // Collection (Application)
                        0x85, 0x01,        //   Report ID (1)
                        0x09, 0x02,        //   Usage (Vendor 2)
                        0x15, 0x00,        //   Logical Minimum (0)
                        0x26, 0xFF, 0x00,  //   Logical Maximum (255)
                        0x75, 0x08,        //   Report Size (8 bits)
                        0x95, 0x08,        //   Report Count (8 bytes)
                        0x81, 0x02,        //   Input (Data,Var,Abs)
                        0x09, 0x03,        //   Usage (Vendor 3)
                        0x91, 0x02,        //   Output (Data,Var,Abs)
                        0xC0               // End Collection</textarea>
                    
                    <div class="troubleshooting">
                        <h3><i class="fas fa-tools"></i> 发送失败常见原因</h3>
                        <ul>
                            <li>报告长度与设备要求不匹配</li>
                            <li>报告ID设置错误</li>
                            <li>设备未准备好接收数据</li>
                            <li>权限问题（尝试重新连接）</li>
                            <li>设备端未正确处理自定义协议</li>
                        </ul>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-signal"></i> 数据接收</h2>
                    <div class="received-data" id="received-data">
等待接收数据...
                    </div>
                    
                    <div class="code-block">
// 接收数据格式示例:
// [ReportID] [DATA1] [DATA2] ... [DATAn]
//
// 示例数据包:
// 01 A1 B2 C3 D4 E5 F6 00 FF
                    </div>
                    
                    <div class="error-details" id="error-details">
                        <!-- 错误详情将显示在这里 -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Modbus调试面板 -->
        <div id="modbus-tab" class="tab-content">
            <div class="content">
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-exchange-alt"></i> 串口连接</h2>
                    
                    <div class="device-info">
                        <div class="info-item">
                            <div class="info-label">连接状态</div>
                            <div class="info-value" id="serial-status">未连接</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">端口名称</div>
                            <div class="info-value" id="serial-port-name">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">波特率</div>
                            <div class="info-value" id="serial-baudrate">-</div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="serial-baudrate-select">波特率</label>
                        <select id="serial-baudrate-select">
                            <option value="9600">9600</option>
                            <option value="19200">19200</option>
                            <option value="38400">38400</option>
                            <option value="57600">57600</option>
                            <option value="115200" selected>115200</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>可用串口</label>
                        <div class="serial-port-list" id="serial-port-list">
                            <div class="serial-port-item">点击"刷新串口"按钮扫描设备</div>
                        </div>
                    </div>
                    
                    <div class="btn-container">
                        <button id="serial-request-permission-btn" class="btn"><i class="fas fa-key"></i> 请求串口权限</button>
                        <button id="serial-refresh-btn" class="btn"><i class="fas fa-sync-alt"></i> 刷新串口</button>
                        <button id="serial-connect-btn" class="btn btn-serial"><i class="fas fa-plug"></i> 连接串口</button>
                        <button id="serial-disconnect-btn" class="btn btn-disconnect"><i class="fas fa-unplug"></i> 断开连接</button>
                    </div>
                    
                    <div class="status">
                        <div class="status-dot" id="serial-status-dot"></div>
                        <span id="serial-status-text">准备连接串口设备...</span>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-sliders-h"></i> Modbus配置</h2>
                    
                    <div class="config-grid">
                        <div class="form-group">
                            <label for="modbus-address">设备地址</label>
                            <input type="number" id="modbus-address" min="1" max="247" value="1">
                        </div>
                        
                        <div class="form-group">
                            <label for="modbus-timeout">超时时间(ms)</label>
                            <input type="number" id="modbus-timeout" min="100" max="10000" value="1000">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="modbus-function">功能码</label>
                        <select id="modbus-function">
                            <option value="1">01 - 读取线圈状态</option>
                            <option value="2">02 - 读取输入状态</option>
                            <option value="3">03 - 读取保持寄存器</option>
                            <option value="4">04 - 读取输入寄存器</option>
                            <option value="5">05 - 写单个线圈</option>
                            <option value="6">06 - 写单个寄存器</option>
                            <option value="15">15 - 写多个线圈</option>
                            <option value="16">16 - 写多个寄存器</option>
                        </select>
                    </div>
                    
                    <div class="modbus-command">
                        <div class="modbus-command-title">
                            <span>命令参数</span>
                        </div>
                        <div class="modbus-command-content" id="modbus-params-container">
                            <!-- 动态生成的参数表 -->
                        </div>
                    </div>
                    
                    <div class="btn-container">
                        <button id="modbus-send-btn" class="btn"><i class="fas fa-paper-plane"></i> 发送Modbus命令</button>
                        <button id="modbus-clear-btn" class="btn"><i class="fas fa-trash"></i> 清除记录</button>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-code"></i> 自定义Modbus帧</h2>
                    
                    <div class="form-group">
                        <label for="modbus-custom-frame">自定义帧 (十六进制, 空格分隔)</label>
                        <input type="text" id="modbus-custom-frame" class="hex-input" placeholder="01 03 00 00 00 01">
                    </div>
                    
                    <div class="btn-container">
                        <button id="modbus-send-custom-btn" class="btn"><i class="fas fa-code"></i> 发送自定义帧</button>
                    </div>
                    
                    <div class="code-block">
// Modbus RTU帧格式:
// [地址] [功能码] [数据] [CRC校验]
//
// 示例读取保持寄存器:
// 01 03 00 00 00 01 84 0A
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-signal"></i> Modbus响应</h2>
                    <div class="received-data" id="modbus-received-data">
等待接收数据...
                    </div>
                    
                    <div class="modbus-response" id="modbus-response-parse">
                        <!-- Modbus响应解析结果将显示在这里 -->
                    </div>
                    
                    <div class="error-details" id="modbus-error-details">
                        <!-- Modbus错误详情将显示在这里 -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- DFU固件升级面板 -->
        <div id="dfu-tab" class="tab-content">
            <div class="content">
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-microchip"></i> DFU设备连接</h2>
                    
                    <div class="device-info">
                        <div class="info-item">
                            <div class="info-label">连接状态</div>
                            <div class="info-value" id="dfu-status">未连接</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">设备名称</div>
                            <div class="info-value" id="dfu-device-name">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">厂商ID (VID)</div>
                            <div class="info-value" id="dfu-vendor-id">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">产品ID (PID)</div>
                            <div class="info-value" id="dfu-product-id">-</div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="dfu-interface-alt">接口备用设置 (Alternate Setting)</label>
                        <input type="number" id="dfu-interface-alt" min="0" max="255" value="0">
                    </div>
                    
                    <div class="btn-container">
                        <button id="dfu-connect-btn" class="btn btn-dfu"><i class="fas fa-plug"></i> 连接DFU设备</button>
                        <button id="dfu-disconnect-btn" class="btn btn-disconnect"><i class="fas fa-unplug"></i> 断开连接</button>
                        <button id="dfu-detect-btn" class="btn"><i class="fas fa-search"></i> 检测DFU模式</button>
                    </div>
                    
                    <div class="status">
                        <div class="status-dot" id="dfu-status-dot"></div>
                        <span id="dfu-status-text">准备连接DFU设备...</span>
                    </div>
                    
                    <div class="dfu-memory-info">
                        <h3><i class="fas fa-memory"></i> 存储器信息</h3>
                        <div class="dfu-memory-row">
                            <span class="dfu-memory-name">Flash起始地址:</span>
                            <span class="dfu-memory-value" id="dfu-flash-start">0x08000000</span>
                        </div>
                        <div class="dfu-memory-row">
                            <span class="dfu-memory-name">Flash大小:</span>
                            <span class="dfu-memory-value" id="dfu-flash-size">512 KB</span>
                        </div>
                        <div class="dfu-memory-row">
                            <span class="dfu-memory-name">页大小:</span>
                            <span class="dfu-memory-value" id="dfu-page-size">2 KB</span>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-upload"></i> 固件升级</h2>
                    
                    <div class="form-group">
                        <label for="dfu-flash-address">Flash起始地址 (十六进制)</label>
                        <input type="text" id="dfu-flash-address" class="hex-input" value="0x08000000">
                    </div>
                    
                    <div class="form-group">
                        <label for="dfu-file">固件文件 (.bin/.hex/.dfu)</label>
                        <input type="file" id="dfu-file" accept=".bin,.hex,.dfu">
                    </div>
                    
                    <div class="dfu-file-info" id="dfu-file-info">
                        未选择文件
                    </div>
                    
                    <div class="dfu-flash-options">
                        <div class="form-group">
                            <label for="dfu-erase-type">擦除类型</label>
                            <select id="dfu-erase-type">
                                <option value="full">全片擦除</option>
                                <option value="sector" selected>按扇区擦除</option>
                                <option value="none">不擦除</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="dfu-chunk-size">传输块大小 (字节)</label>
                            <input type="number" id="dfu-chunk-size" min="32" max="65536" value="1024">
                        </div>
                    </div>
                    
                    <div class="btn-container">
                        <button id="dfu-upload-btn" class="btn btn-dfu"><i class="fas fa-upload"></i> 上传固件</button>
                        <button id="dfu-verify-btn" class="btn"><i class="fas fa-check"></i> 验证固件</button>
                        <button id="dfu-reset-btn" class="btn"><i class="fas fa-power-off"></i> 复位设备</button>
                    </div>
                    
                    <div class="dfu-progress-container">
                        <div>升级进度</div>
                        <div class="dfu-progress-bar">
                            <div class="dfu-progress" id="dfu-progress">0%</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-terminal"></i> DFU控制命令</h2>
                    
                    <div class="btn-container">
                        <button id="dfu-get-status-btn" class="btn"><i class="fas fa-info-circle"></i> 获取状态</button>
                        <button id="dfu-abort-btn" class="btn"><i class="fas fa-stop-circle"></i> 中止操作</button>
                        <button id="dfu-clear-status-btn" class="btn"><i class="fas fa-broom"></i> 清除状态</button>
                    </div>
                    
                    <div class="dfu-command">
                        <div class="form-group">
                            <label for="dfu-command">DFU命令</label>
                            <select id="dfu-command">
                                <option value="0x00">DFU_DETACH</option>
                                <option value="0x01">DFU_DNLOAD</option>
                                <option value="0x02">DFU_UPLOAD</option>
                                <option value="0x03">DFU_GETSTATUS</option>
                                <option value="0x04">DFU_CLRSTATUS</option>
                                <option value="0x05">DFU_GETSTATE</option>
                                <option value="0x06">DFU_ABORT</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="dfu-command-data">命令数据 (十六进制, 空格分隔)</label>
                            <input type="text" id="dfu-command-data" class="hex-input" placeholder="可选数据">
                        </div>
                        
                        <button id="dfu-send-command-btn" class="btn"><i class="fas fa-paper-plane"></i> 发送命令</button>
                    </div>
                    
                    <div class="received-data" id="dfu-received-data">
等待DFU响应...
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title"><i class="fas fa-info-circle"></i> DFU信息</h2>
                    
                    <div class="code-block">
// DFU协议说明:
// 1. 设备必须处于DFU模式
// 2. 典型升级流程:
//    - 连接设备
//    - 选择固件文件
//    - (可选) 擦除Flash
//    - 上传固件
//    - 验证固件
//    - 复位设备
//
// 支持的DFU模式:
// - STM32 DFU
// - Atmel DFU
// - Nordic DFU
// - 通用DFU设备
                    </div>
                    
                    <div class="troubleshooting">
                        <h3><i class="fas fa-tools"></i> DFU常见问题</h3>
                        <ul>
                            <li>确保设备已进入DFU模式</li>
                            <li>检查VID/PID是否匹配</li>
                            <li>验证Flash地址是否正确</li>
                            <li>尝试不同的备用设置(Alternate Setting)</li>
                            <li>检查USB连接是否稳定</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>基于 WebHID / WebSerial / WebUSB API 技术 | 仅支持 Chrome 89+ 或 Edge 89+ 浏览器</p>
            <p>注意：首次连接需要用户授权，请确保您的设备支持相应协议</p>
        </div>
    </div>
    
    <div id="notification" class="notification"></div>

    <!-- 下一部分将包含JavaScript代码 -->
         <script>
        // =============================================
        // 全局变量和DOM元素
        // =============================================
        let hidDevice = null;
        let serialPort = null;
        let serialReader = null;
        let dfuDevice = null;
        let dfuInterface = null;
        let receivedData = '';
        let reportLength = 8;
        let modbusHistory = [];
        let dfuFile = null;
        let dfuFileArrayBuffer = null;
        let dfuTransferSize = 1024;
        let dfuProgress = 0;
        let dfuState = 'dfuIDLE';
        
        // HID相关DOM元素
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const refreshBtn = document.getElementById('refresh-btn');
        const sendBtn = document.getElementById('send-btn');
        const clearBtn = document.getElementById('clear-btn');
        const testBtn = document.getElementById('test-btn');
        const connectionStatus = document.getElementById('connection-status');
        const deviceName = document.getElementById('device-name');
        const vendorId = document.getElementById('vendor-id');
        const productId = document.getElementById('product-id');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const receivedDataElement = document.getElementById('received-data');
        const historyContainer = document.getElementById('history-container');
        const errorDetails = document.getElementById('error-details');
        const dataSizeInput = document.getElementById('data-size');
        
        // Modbus相关DOM元素
        const serialRequestPermissionBtn = document.getElementById('serial-request-permission-btn');
        const serialRefreshBtn = document.getElementById('serial-refresh-btn');
        const serialConnectBtn = document.getElementById('serial-connect-btn');
        const serialDisconnectBtn = document.getElementById('serial-disconnect-btn');
        const serialStatus = document.getElementById('serial-status');
        const serialPortName = document.getElementById('serial-port-name');
        const serialBaudrate = document.getElementById('serial-baudrate');
        const serialStatusText = document.getElementById('serial-status-text');
        const serialStatusDot = document.getElementById('serial-status-dot');
        const modbusSendBtn = document.getElementById('modbus-send-btn');
        const modbusClearBtn = document.getElementById('modbus-clear-btn');
        const modbusSendCustomBtn = document.getElementById('modbus-send-custom-btn');
        const modbusReceivedData = document.getElementById('modbus-received-data');
        const modbusResponseParse = document.getElementById('modbus-response-parse');
        const modbusErrorDetails = document.getElementById('modbus-error-details');
        const modbusParamsContainer = document.getElementById('modbus-params-container');
        const serialPortList = document.getElementById('serial-port-list');
        
        // DFU相关DOM元素
        const dfuConnectBtn = document.getElementById('dfu-connect-btn');
        const dfuDisconnectBtn = document.getElementById('dfu-disconnect-btn');
        const dfuDetectBtn = document.getElementById('dfu-detect-btn');
        const dfuStatus = document.getElementById('dfu-status');
        const dfuDeviceName = document.getElementById('dfu-device-name');
        const dfuVendorId = document.getElementById('dfu-vendor-id');
        const dfuProductId = document.getElementById('dfu-product-id');
        const dfuStatusText = document.getElementById('dfu-status-text');
        const dfuStatusDot = document.getElementById('dfu-status-dot');
        const dfuFileInput = document.getElementById('dfu-file');
        const dfuFileInfo = document.getElementById('dfu-file-info');
        const dfuProgressBar = document.getElementById('dfu-progress');
        const dfuUploadBtn = document.getElementById('dfu-upload-btn');
        const dfuVerifyBtn = document.getElementById('dfu-verify-btn');
        const dfuResetBtn = document.getElementById('dfu-reset-btn');
        const dfuReceivedData = document.getElementById('dfu-received-data');
        const dfuGetStatusBtn = document.getElementById('dfu-get-status-btn');
        const dfuAbortBtn = document.getElementById('dfu-abort-btn');
        const dfuClearStatusBtn = document.getElementById('dfu-clear-status-btn');
        const dfuSendCommandBtn = document.getElementById('dfu-send-command-btn');
        
        const notification = document.getElementById('notification');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // =============================================
        // 通用功能函数
        // =============================================
        
        // 切换标签页
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });
        
        // 显示通知
        function showNotification(message, type) {
            notification.textContent = message;
            notification.className = 'notification';
            
            if (type === 'success') {
                notification.classList.add('notification-success');
            } else if (type === 'error') {
                notification.classList.add('notification-error');
            } else if (type === 'warning') {
                notification.classList.add('notification-warning');
            } else if (type === 'info') {
                notification.classList.add('notification-info');
            }
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // 更新状态显示
        function updateStatus(text, status, isSerial = false, isDfu = false) {
            let statusElement, dotElement;
            
            if (isDfu) {
                statusElement = dfuStatusText;
                dotElement = dfuStatusDot;
            } else if (isSerial) {
                statusElement = serialStatusText;
                dotElement = serialStatusDot;
            } else {
                statusElement = statusText;
                dotElement = statusDot;
            }
            
            statusElement.textContent = text;
            dotElement.className = 'status-dot';
            
            if (status === 'connected') {
                dotElement.classList.add('status-connected');
            } else if (status === 'disconnected') {
                dotElement.classList.add('status-disconnected');
            } else {
                dotElement.classList.add('status-pending');
            }
        }
        
        // 显示错误详情
        function displayErrorDetails(error, isModbus = false, isDfu = false) {
            const container = isDfu ? dfuReceivedData : 
                              isModbus ? modbusErrorDetails : errorDetails;
            
            container.innerHTML = `
                <h3><i class="fas fa-bug"></i> 错误详情</h3>
                <div><strong>错误信息:</strong> ${error.message || '未知错误'}</div>
                <div><strong>错误类型:</strong> ${error.name || 'N/A'}</div>
                ${error.stack ? `<div><strong>调用栈:</strong><pre>${error.stack}</pre></div>` : ''}
            `;
        }
        
        // 字节数组转十六进制字符串
        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => 
                b.toString(16).padStart(2, '0').toUpperCase()
            ).join(' ');
        }
        
        // 十六进制字符串转字节数组
        function hexToBytes(hexString) {
            const hexParts = hexString.trim().split(/\s+/).filter(part => part.length > 0);
            const bytes = [];
            
            for (const part of hexParts) {
                // 处理带0x前缀的十六进制
                let hexValue = part;
                if (part.toLowerCase().startsWith('0x')) {
                    hexValue = part.substring(2);
                }
                
                // 处理单字节
                if (hexValue.length === 1) {
                    bytes.push(parseInt(hexValue, 16));
                } 
                // 处理双字节
                else if (hexValue.length === 2) {
                    bytes.push(parseInt(hexValue, 16));
                }
                // 处理长字符串
                else {
                    for (let i = 0; i < hexValue.length; i += 2) {
                        const byte = hexValue.substring(i, i + 2);
                        if (byte.length > 0) {
                            bytes.push(parseInt(byte, 16));
                        }
                    }
                }
            }
            
            return new Uint8Array(bytes);
        }
        
        // 计算Modbus CRC16校验
        function calculateCRC(data) {
            let crc = 0xFFFF;
            for (let i = 0; i < data.length; i++) {
                crc ^= data[i];
                for (let j = 0; j < 8; j++) {
                    if (crc & 0x0001) {
                        crc = (crc >> 1) ^ 0xA001;
                    } else {
                        crc = crc >> 1;
                    }
                }
            }
            return new Uint8Array([crc & 0xFF, (crc >> 8) & 0xFF]);
        }
        
        // =============================================
        // HID功能实现
        // =============================================
        
        // 检查浏览器是否支持WebHID
        if (!navigator.hid) {
            statusText.textContent = "错误：您的浏览器不支持WebHID API。请使用Chrome 89+或Edge 89+。";
            statusDot.classList.add('status-disconnected');
            connectBtn.disabled = true;
            refreshBtn.disabled = true;
        }
        
        // 更新报告长度
        dataSizeInput.addEventListener('change', () => {
            reportLength = parseInt(dataSizeInput.value) || 8;
            document.getElementById('command-data').placeholder = 
                `输入 ${reportLength} 字节十六进制数据 (例如: ${Array.from({length: reportLength}, () => 'AA').join(' ')})`;
        });
        
        // 连接HID设备
        connectBtn.addEventListener('click', async () => {
            try {
                showNotification('正在请求设备访问权限...', 'pending');
                updateStatus('正在连接...', 'pending');
                errorDetails.innerHTML = '';
                
                const filters = [];
                const devices = await navigator.hid.requestDevice({ filters });
                
                if (devices.length === 0) {
                    showNotification('未选择设备', 'warning');
                    updateStatus('未选择设备', 'disconnected');
                    return;
                }
                
                hidDevice = devices[0];
                await hidDevice.open();
                
                // 更新设备信息
                connectionStatus.textContent = '已连接';
                deviceName.textContent = hidDevice.productName || '未知设备';
                vendorId.textContent = '0x' + hidDevice.vendorId.toString(16).toUpperCase();
                productId.textContent = '0x' + hidDevice.productId.toString(16).toUpperCase();
                
                // 设置接收数据监听器
                hidDevice.addEventListener('inputreport', handleInputReport);
                
                // 获取输出报告长度
                if (hidDevice.collections && hidDevice.collections.length > 0) {
                    const outputReports = hidDevice.collections.flatMap(c => c.outputReports || []);
                    if (outputReports.length > 0) {
                        const report = outputReports[0];
                        if (report.items) {
                            const dataItems = report.items.filter(item => item.kind === 'data');
                            if (dataItems.length > 0) {
                                const totalBits = dataItems.reduce((sum, item) => sum + (item.reportSize || 0) * (item.reportCount || 0), 0);
                                const reportBytes = Math.ceil(totalBits / 8);
                                if (reportBytes > 0) {
                                    reportLength = reportBytes;
                                    dataSizeInput.value = reportBytes;
                                    showNotification(`检测到报告长度: ${reportBytes} 字节`, 'success');
                                }
                            }
                        }
                    }
                }
                
                showNotification(`已连接: ${hidDevice.productName || 'HID设备'}`, 'success');
                updateStatus('已连接 - 等待数据...', 'connected');
                
                // 禁用连接按钮
                connectBtn.disabled = true;
                
            } catch (error) {
                console.error('连接错误:', error);
                showNotification(`连接失败: ${error.message}`, 'error');
                updateStatus('连接失败', 'disconnected');
                displayErrorDetails(error);
            }
        });
        
        // 刷新HID设备
        refreshBtn.addEventListener('click', () => {
            if (hidDevice) {
                hidDevice.close();
                hidDevice = null;
            }
            
            connectionStatus.textContent = '未连接';
            deviceName.textContent = '-';
            vendorId.textContent = '-';
            productId.textContent = '-';
            errorDetails.innerHTML = '';
            
            // 重新启用连接按钮
            connectBtn.disabled = false;
            
            showNotification('已重置设备状态', 'info');
            updateStatus('准备连接设备...', 'disconnected');
        });
        
        // 断开HID设备
        disconnectBtn.addEventListener('click', async () => {
            if (!hidDevice) return;
            
            try {
                await hidDevice.close();
                hidDevice = null;
                
                // 重置设备信息
                connectionStatus.textContent = '未连接';
                deviceName.textContent = '-';
                vendorId.textContent = '-';
                productId.textContent = '-';
                
                // 重新启用连接按钮
                connectBtn.disabled = false;
                
                showNotification('设备已断开', 'info');
                updateStatus('设备已断开', 'disconnected');
                
            } catch (error) {
                console.error('断开连接错误:', error);
                showNotification(`断开连接失败: ${error.message}`, 'error');
                displayErrorDetails(error);
            }
        });
        
        // 发送测试数据
        testBtn.addEventListener('click', () => {
            // 生成测试数据
            const testData = Array.from({length: reportLength}, () => {
                return Math.floor(Math.random() * 256).toString(16).padStart(2, '0').toUpperCase();
            }).join(' ');
            
            document.getElementById('command-data').value = testData;
            showNotification('已生成测试数据', 'info');
        });
        
        // 发送HID数据
        sendBtn.addEventListener('click', async () => {
            if (!hidDevice) {
                showNotification('错误：未连接设备', 'error');
                return;
            }
            
            try {
                const reportId = parseInt(document.getElementById('report-id').value) || 1;
                const hexData = document.getElementById('command-data').value;
                const dataSize = parseInt(document.getElementById('data-size').value) || reportLength;
                
                // 解析十六进制数据
                const dataArray = hexToBytes(hexData);
                
                // 检查数据长度
                if (dataArray.length > dataSize) {
                    showNotification(`数据过长（${dataArray.length}字节），将被截断`, 'warning');
                    dataArray.length = dataSize;
                } else if (dataArray.length < dataSize) {
                    showNotification(`数据不足（${dataArray.length}字节），将用0填充`, 'warning');
                    while (dataArray.length < dataSize) {
                        dataArray.push(0x00);
                    }
                }
                
                // 准备报告数据 (payload, 不包含reportId)
                const outputData = dataArray;
                
                // 发送数据
                await hidDevice.sendReport(reportId, outputData);
                
                // 添加到命令历史 (包含报告ID的数据)
                const fullData = new Uint8Array([reportId, ...dataArray]);
                addToHistory(fullData);
                
                showNotification('命令已发送', 'success');
                
            } catch (error) {
                console.error('发送错误:', error);
                showNotification(`发送失败: ${error.message}`, 'error');
                displayErrorDetails(error);
                
                // 提供具体解决方案
                if (error.message.includes('Failed to write the report')) {
                    errorDetails.innerHTML = `
                        <h3><i class="fas fa-exclamation-triangle"></i> 发送失败解决方案</h3>
                        <ul>
                            <li>检查报告ID是否正确（通常为1-255）</li>
                            <li>确保数据长度与设备要求一致</li>
                            <li>尝试重新连接设备</li>
                            <li>检查设备是否处于可接收数据状态</li>
                            <li>验证设备端固件是否正确处理HID输出报告</li>
                        </ul>
                    `;
                }
            }
        });
        
        // 处理HID接收到的数据
        function handleInputReport(event) {
            const { data, reportId } = event;
            const dataArray = Array.from(new Uint8Array(data.buffer));
            
            // 格式化接收到的数据
            const hexString = bytesToHex(dataArray);
            const timestamp = new Date().toLocaleTimeString();
            
            // 添加到接收数据框
            receivedData = `[${timestamp}] [Report ID: ${reportId}] ${hexString}\n${receivedData}`;
            receivedDataElement.textContent = receivedData;
            
            // 滚动到顶部
            receivedDataElement.scrollTop = 0;
        }
        
        // 添加到HID命令历史
        function addToHistory(dataArray) {
            const timestamp = new Date().toLocaleTimeString();
            const hexString = bytesToHex(dataArray);
            
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.innerHTML = `
                <div class="history-time">${timestamp}</div>
                <div class="history-data">${hexString}</div>
            `;
            
            historyContainer.prepend(historyItem);
            
            // 限制历史记录数量
            if (historyContainer.children.length > 20) {
                historyContainer.removeChild(historyContainer.lastChild);
            }
        }
        
        // 清除HID数据
        clearBtn.addEventListener('click', () => {
            receivedData = '';
            receivedDataElement.textContent = '数据已清除...';
            historyContainer.innerHTML = '';
            errorDetails.innerHTML = '';
            showNotification('数据记录已清除', 'info');
        });
        
        // =============================================
        // Modbus功能实现
        // =============================================
        
        // 检查浏览器是否支持WebSerial
        if (!navigator.serial) {
            serialStatusText.textContent = "错误：您的浏览器不支持WebSerial API。请使用Chrome 89+或Edge 89+。";
            serialStatusDot.classList.add('status-disconnected');
            serialConnectBtn.disabled = true;
            serialRefreshBtn.disabled = true;
        }
        
        // 初始化Modbus参数界面
        function initModbusParams() {
            const functionCode = document.getElementById('modbus-function').value;
            let paramsHtml = '';
            
            switch(functionCode) {
                case '1': // 读取线圈状态
                case '2': // 读取输入状态
                    paramsHtml = `
                        <div class="form-group">
                            <label for="modbus-start-addr">起始地址</label>
                            <input type="number" id="modbus-start-addr" min="0" max="65535" value="0">
                        </div>
                        <div class="form-group">
                            <label for="modbus-length">读取长度</label>
                            <input type="number" id="modbus-length" min="1" max="2000" value="1">
                        </div>
                    `;
                    break;
                    
                case '3': // 读取保持寄存器
                case '4': // 读取输入寄存器
                    paramsHtml = `
                        <div class="form-group">
                            <label for="modbus-start-addr">起始地址</label>
                            <input type="number" id="modbus-start-addr" min="0" max="65535" value="0">
                        </div>
                        <div class="form-group">
                            <label for="modbus-length">寄存器数量</label>
                            <input type="number" id="modbus-length" min="1" max="125" value="1">
                        </div>
                    `;
                    break;
                    
                case '5': // 写单个线圈
                    paramsHtml = `
                        <div class="form-group">
                            <label for="modbus-start-addr">线圈地址</label>
                            <input type="number" id="modbus-start-addr" min="0" max="65535" value="0">
                        </div>
                        <div class="form-group">
                            <label for="modbus-value">状态值</label>
                            <select id="modbus-value">
                                <option value="0xFF00">ON (0xFF00)</option>
                                <option value="0x0000">OFF (0x0000)</option>
                            </select>
                        </div>
                    `;
                    break;
                    
                case '6': // 写单个寄存器
                    paramsHtml = `
                        <div class="form-group">
                            <label for="modbus-start-addr">寄存器地址</label>
                            <input type="number" id="modbus-start-addr" min="0" max="65535" value="0">
                        </div>
                        <div class="form-group">
                            <label for="modbus-value">寄存器值</label>
                            <input type="number" id="modbus-value" min="0" max="65535" value="0">
                        </div>
                    `;
                    break;
                    
                case '15': // 写多个线圈
                    paramsHtml = `
                        <div class="form-group">
                            <label for="modbus-start-addr">起始地址</label>
                            <input type="number" id="modbus-start-addr" min="0" max="65535" value="0">
                        </div>
                        <div class="form-group">
                            <label for="modbus-length">线圈数量</label>
                            <input type="number" id="modbus-length" min="1" max="1968" value="1">
                        </div>
                        <div class="form-group">
                            <label for="modbus-values">线圈状态 (十六进制)</label>
                            <input type="text" id="modbus-values" class="hex-input" value="01">
                        </div>
                    `;
                    break;
                    
                case '16': // 写多个寄存器
                    paramsHtml = `
                        <div class="form-group">
                            <label for="modbus-start-addr">起始地址</label>
                            <input type="number" id="modbus-start-addr" min="0" max="65535" value="0">
                        </div>
                        <div class="form-group">
                            <label for="modbus-length">寄存器数量</label>
                            <input type="number" id="modbus-length" min="1" max="123" value="1">
                        </div>
                        <div class="form-group">
                            <label for="modbus-values">寄存器值 (十六进制, 空格分隔)</label>
                            <input type="text" id="modbus-values" class="hex-input" value="00 01">
                        </div>
                    `;
                    break;
            }
            
            modbusParamsContainer.innerHTML = paramsHtml;
        }
        
        // 功能码变化时更新参数界面
        document.getElementById('modbus-function').addEventListener('change', initModbusParams);
        initModbusParams(); // 初始化
        
        // 刷新串口列表
        async function refreshSerialPorts() {
            try {
                if (!navigator.serial) {
                    showNotification('浏览器不支持WebSerial API', 'error');
                    return;
                }
                
                // 首先请求串口访问权限（如果需要的话）
                try {
                    const ports = await navigator.serial.getPorts();
                    serialPortList.innerHTML = '';
                    
                    if (ports.length === 0) {
                        serialPortList.innerHTML = '<div class="serial-port-item">未找到串口设备，请先连接USB串口设备</div>';
                        return;
                    }
                    
                    ports.forEach(port => {
                        const portItem = document.createElement('div');
                        portItem.className = 'serial-port-item';
                        
                        // 尝试获取USB信息
                        const info = port.getInfo();
                        let displayText = '串口设备';
                        
                        if (info.usbVendorId && info.usbProductId) {
                            displayText = `USB设备 (VID: 0x${info.usbVendorId.toString(16).padStart(4, '0')}, PID: 0x${info.usbProductId.toString(16).padStart(4, '0')})`;
                        }
                        
                        portItem.textContent = displayText;
                        
                        portItem.addEventListener('click', () => {
                            document.querySelectorAll('.serial-port-item').forEach(item => {
                                item.classList.remove('active');
                            });
                            portItem.classList.add('active');
                        });
                        
                        serialPortList.appendChild(portItem);
                    });
                    
                    showNotification(`找到 ${ports.length} 个串口设备`, 'success');
                    
                } catch (error) {
                    console.error('获取串口列表错误:', error);
                    serialPortList.innerHTML = '<div class="serial-port-item">获取串口列表失败，请先请求串口权限</div>';
                    throw error;
                }
                
            } catch (error) {
                console.error('刷新串口错误:', error);
                showNotification(`刷新串口失败: ${error.message}`, 'error');
                displayErrorDetails(error, true);
            }
        }
        
        // 连接串口
        async function connectSerialPort() {
            try {
                if (!navigator.serial) {
                    showNotification('浏览器不支持WebSerial API', 'error');
                    return;
                }
                
                let selectedPort = null;
                
                // 检查是否有已选择的串口
                const selectedPortItem = document.querySelector('.serial-port-item.active');
                if (selectedPortItem && selectedPortItem.textContent !== '未找到串口设备，请先连接USB串口设备' && selectedPortItem.textContent !== '获取串口列表失败，请先请求串口权限') {
                    const ports = await navigator.serial.getPorts();
                    const portIndex = Array.from(document.querySelectorAll('.serial-port-item')).indexOf(selectedPortItem);
                    if (portIndex >= 0 && portIndex < ports.length) {
                        selectedPort = ports[portIndex];
                    }
                }
                
                // 如果没有选中的串口，请求用户选择
                if (!selectedPort) {
                    try {
                        selectedPort = await navigator.serial.requestPort();
                    } catch (error) {
                        if (error.name === 'NotFoundError') {
                            showNotification('用户取消了串口选择', 'warning');
                            return;
                        } else {
                            throw error;
                        }
                    }
                }
                
                if (!selectedPort) {
                    showNotification('未选择有效的串口', 'error');
                    return;
                }
                
                serialPort = selectedPort;
                const baudRate = parseInt(document.getElementById('serial-baudrate-select').value) || 115200;
                
                await serialPort.open({
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: "none",
                    flowControl: "none"
                });
                
                // 更新UI状态
                serialStatus.textContent = '已连接';
                
                const info = serialPort.getInfo();
                if (info.usbVendorId && info.usbProductId) {
                    serialPortName.textContent = `USB设备 (VID: 0x${info.usbVendorId.toString(16).padStart(4, '0')}, PID: 0x${info.usbProductId.toString(16).padStart(4, '0')})`;
                } else {
                    serialPortName.textContent = '串口设备';
                }
                
                serialBaudrate.textContent = baudRate;
                
                // 开始读取数据
                readSerialData();
                
                // 禁用连接按钮
                serialConnectBtn.disabled = true;
                
                showNotification('串口连接成功', 'success');
                updateStatus('已连接 - 等待数据...', 'connected', true);
                
            } catch (error) {
                console.error('串口连接错误:', error);
                showNotification(`串口连接失败: ${error.message}`, 'error');
                updateStatus('连接失败', 'disconnected', true);
                displayErrorDetails(error, true);
                
                if (serialPort) {
                    try {
                        await serialPort.close();
                    } catch (e) {
                        console.error('关闭串口错误:', e);
                    }
                    serialPort = null;
                }
            }
        }
        
        // 读取串口数据
        async function readSerialData() {
            if (!serialPort || !serialPort.readable) return;
            
            try {
                while (serialPort.readable) {
                    serialReader = serialPort.readable.getReader();
                    
                    try {
                        while (true) {
                            const { value, done } = await serialReader.read();
                            if (done) break;
                            
                            // 处理接收到的数据
                            handleSerialData(value);
                        }
                    } catch (error) {
                        console.error('读取串口数据错误:', error);
                        showNotification(`读取数据失败: ${error.message}`, 'error');
                        displayErrorDetails(error, true);
                    } finally {
                        serialReader.releaseLock();
                    }
                }
            } catch (error) {
                console.error('串口读取错误:', error);
                showNotification(`串口读取失败: ${error.message}`, 'error');
                displayErrorDetails(error, true);
            }
        }
        
        // 处理串口接收到的数据
        function handleSerialData(data) {
            const hexString = bytesToHex(new Uint8Array(data.buffer));
            const timestamp = new Date().toLocaleTimeString();
            
            // 添加到接收数据框
            modbusReceivedData.textContent = `[${timestamp}] ${hexString}\n${modbusReceivedData.textContent}`;
            
            // 尝试解析Modbus响应
            tryParseModbusResponse(new Uint8Array(data.buffer));
        }
        
        // 尝试解析Modbus响应
        function tryParseModbusResponse(data) {
            if (data.length < 5) return; // 最小Modbus响应长度
            
            const address = data[0];
            const functionCode = data[1];
            
            let responseInfo = '';
            
            try {
                switch(functionCode) {
                    case 0x01: // 读取线圈状态
                    case 0x02: // 读取输入状态
                        const byteCount = data[2];
                        const coilStatus = Array.from(data.slice(3, 3 + byteCount)).map(b => b.toString(2).padStart(8, '0')).join(' ');
                        responseInfo = `线圈状态 (${byteCount}字节): ${coilStatus}`;
                        break;
                        
                    case 0x03: // 读取保持寄存器
                    case 0x04: // 读取输入寄存器
                        const registerCount = data[2] / 2;
                        const registers = [];
                        for (let i = 0; i < registerCount; i++) {
                            const offset = 3 + i * 2;
                            registers.push((data[offset] << 8) | data[offset + 1]);
                        }
                        responseInfo = `寄存器值 (${registerCount}个): ${registers.join(', ')}`;
                        break;
                        
                    case 0x05: // 写单个线圈
                    case 0x06: // 写单个寄存器
                        const addr = (data[2] << 8) | data[3];
                        const value = (data[4] << 8) | data[5];
                        responseInfo = `写入成功 - 地址: ${addr}, 值: ${value}`;
                        break;
                        
                    case 0x0F: // 写多个线圈
                    case 0x10: // 写多个寄存器
                        const startAddr = (data[2] << 8) | data[3];
                        const quantity = (data[4] << 8) | data[5];
                        responseInfo = `写入成功 - 起始地址: ${startAddr}, 数量: ${quantity}`;
                        break;
                        
                    default:
                        if (functionCode >= 0x80) {
                            // Modbus异常响应
                            const errorCode = data[2];
                            const errorMessages = {
                                0x01: '非法功能码',
                                0x02: '非法数据地址',
                                0x03: '非法数据值',
                                0x04: '从站设备故障',
                                0x05: '确认',
                                0x06: '从站设备忙',
                                0x08: '存储奇偶性错误',
                                0x0A: '网关路径不可用',
                                0x0B: '网关目标设备响应失败'
                            };
                            responseInfo = `错误响应: ${errorMessages[errorCode] || '未知错误'} (代码: 0x${errorCode.toString(16)})`;
                        } else {
                            responseInfo = '未知功能码响应';
                        }
                }
                
                modbusResponseParse.innerHTML = `
                    <div><strong>解析结果:</strong> ${responseInfo}</div>
                    <div><strong>设备地址:</strong> ${address}</div>
                    <div><strong>功能码:</strong> 0x${functionCode.toString(16).toUpperCase()}</div>
                `;
                
            } catch (error) {
                console.error('解析Modbus响应错误:', error);
                modbusResponseParse.innerHTML = '<div style="color:#ff5252">无法解析Modbus响应</div>';
            }
        }
        
        // 构建Modbus RTU帧
        function buildModbusFrame(address, functionCode, data = []) {
            const frame = new Uint8Array([address, functionCode, ...data]);
            const crc = calculateCRC(frame);
            return new Uint8Array([...frame, ...crc]);
        }
        
        // 发送Modbus命令
        async function sendModbusCommand() {
            if (!serialPort || !serialPort.writable) {
                showNotification('错误：串口未连接或不可写', 'error');
                return;
            }
            
            try {
                const address = parseInt(document.getElementById('modbus-address').value) || 1;
                const functionCode = parseInt(document.getElementById('modbus-function').value) || 3;
                const timeout = parseInt(document.getElementById('modbus-timeout').value) || 1000;
                
                let modbusFrame;
                
                switch(functionCode) {
                    case 1: // 读取线圈状态
                    case 2: // 读取输入状态
                        const startAddr1 = parseInt(document.getElementById('modbus-start-addr').value) || 0;
                        const length1 = parseInt(document.getElementById('modbus-length').value) || 1;
                        modbusFrame = buildModbusFrame(address, functionCode, [
                            (startAddr1 >> 8) & 0xFF, startAddr1 & 0xFF,
                            (length1 >> 8) & 0xFF, length1 & 0xFF
                        ]);
                        break;
                        
                    case 3: // 读取保持寄存器
                    case 4: // 读取输入寄存器
                        const startAddr2 = parseInt(document.getElementById('modbus-start-addr').value) || 0;
                        const length2 = parseInt(document.getElementById('modbus-length').value) || 1;
                        modbusFrame = buildModbusFrame(address, functionCode, [
                            (startAddr2 >> 8) & 0xFF, startAddr2 & 0xFF,
                            (length2 >> 8) & 0xFF, length2 & 0xFF
                        ]);
                        break;
                        
                    case 5: // 写单个线圈
                        const coilAddr = parseInt(document.getElementById('modbus-start-addr').value) || 0;
                        const coilValue = document.getElementById('modbus-value').value;
                        const value5 = coilValue.startsWith('0x') ? parseInt(coilValue, 16) : parseInt(coilValue);
                        modbusFrame = buildModbusFrame(address, functionCode, [
                            (coilAddr >> 8) & 0xFF, coilAddr & 0xFF,
                            (value5 >> 8) & 0xFF, value5 & 0xFF
                        ]);
                        break;
                        
                    case 6: // 写单个寄存器
                        const regAddr = parseInt(document.getElementById('modbus-start-addr').value) || 0;
                        const regValue = parseInt(document.getElementById('modbus-value').value) || 0;
                        modbusFrame = buildModbusFrame(address, functionCode, [
                            (regAddr >> 8) & 0xFF, regAddr & 0xFF,
                            (regValue >> 8) & 0xFF, regValue & 0xFF
                        ]);
                        break;
                        
                    case 15: // 写多个线圈
                        const startAddr15 = parseInt(document.getElementById('modbus-start-addr').value) || 0;
                        const length15 = parseInt(document.getElementById('modbus-length').value) || 1;
                        const values15 = hexToBytes(document.getElementById('modbus-values').value || '01');
                        modbusFrame = buildModbusFrame(address, functionCode, [
                            (startAddr15 >> 8) & 0xFF, startAddr15 & 0xFF,
                            (length15 >> 8) & 0xFF, length15 & 0xFF,
                            values15.length, ...values15
                        ]);
                        break;
                        
                    case 16: // 写多个寄存器
                        const startAddr16 = parseInt(document.getElementById('modbus-start-addr').value) || 0;
                        const length16 = parseInt(document.getElementById('modbus-length').value) || 1;
                        const values16 = hexToBytes(document.getElementById('modbus-values').value || '00 01');
                        modbusFrame = buildModbusFrame(address, functionCode, [
                            (startAddr16 >> 8) & 0xFF, startAddr16 & 0xFF,
                            (length16 >> 8) & 0xFF, length16 & 0xFF,
                            values16.length, ...values16
                        ]);
                        break;
                        
                    default:
                        throw new Error('不支持的功能码');
                }
                
                // 发送数据
                const writer = serialPort.writable.getWriter();
                await writer.write(modbusFrame);
                writer.releaseLock();
                
                // 添加到历史
                const timestamp = new Date().toLocaleTimeString();
                const hexString = bytesToHex(modbusFrame);
                modbusHistory.unshift({ time: timestamp, data: hexString });
                
                if (modbusHistory.length > 20) {
                    modbusHistory.pop();
                }
                
                showNotification('Modbus命令已发送', 'success');
                
            } catch (error) {
                console.error('发送Modbus命令错误:', error);
                showNotification(`发送Modbus命令失败: ${error.message}`, 'error');
                displayErrorDetails(error, true);
            }
        }
        
        // 发送自定义Modbus帧
        async function sendCustomModbusFrame() {
            if (!serialPort || !serialPort.writable) {
                showNotification('错误：串口未连接或不可写', 'error');
                return;
            }
            
            try {
                const hexString = document.getElementById('modbus-custom-frame').value;
                if (!hexString.trim()) {
                    showNotification('请输入有效的Modbus帧', 'warning');
                    return;
                }
                
                let data = hexToBytes(hexString);
                
                // 如果数据长度至少2字节且没有CRC，则自动计算CRC
                if (data.length >= 2 && data.length <= 252) {
                    const frameWithoutCRC = data.slice(0, -2);
                    const calculatedCRC = calculateCRC(frameWithoutCRC);
                    
                    // 检查是否已经有CRC
                    const existingCRC = data.slice(-2);
                    if (existingCRC[0] !== calculatedCRC[0] || existingCRC[1] !== calculatedCRC[1]) {
                        // 替换为正确的CRC
                        data = new Uint8Array([...frameWithoutCRC, ...calculatedCRC]);
                        showNotification('已自动计算并添加CRC校验', 'info');
                    }
                }
                
                // 发送数据
                const writer = serialPort.writable.getWriter();
                await writer.write(data);
                writer.releaseLock();
                
                // 添加到历史
                const timestamp = new Date().toLocaleTimeString();
                const sentHexString = bytesToHex(data);
                modbusHistory.unshift({ time: timestamp, data: sentHexString });
                
                if (modbusHistory.length > 20) {
                    modbusHistory.pop();
                }
                
                showNotification('自定义Modbus帧已发送', 'success');
                
            } catch (error) {
                console.error('发送自定义帧错误:', error);
                showNotification(`发送自定义帧失败: ${error.message}`, 'error');
                displayErrorDetails(error, true);
            }
        }
        
        // 断开串口连接
        async function disconnectSerialPort() {
            if (!serialPort) return;
            
            try {
                if (serialReader) {
                    await serialReader.cancel();
                    serialReader.releaseLock();
                    serialReader = null;
                }
                
                await serialPort.close();
                serialPort = null;
                
                // 更新UI状态
                serialStatus.textContent = '未连接';
                serialPortName.textContent = '-';
                serialBaudrate.textContent = '-';
                
                // 重新启用连接按钮
                serialConnectBtn.disabled = false;
                
                showNotification('串口已断开', 'info');
                updateStatus('串口已断开', 'disconnected', true);
                
            } catch (error) {
                console.error('断开串口连接错误:', error);
                showNotification(`断开串口失败: ${error.message}`, 'error');
                displayErrorDetails(error, true);
            }
        }
        
        // 清除Modbus数据
        function clearModbusData() {
            modbusReceivedData.textContent = '等待接收数据...';
            modbusResponseParse.innerHTML = '';
            modbusErrorDetails.innerHTML = '';
            modbusHistory = [];
            showNotification('Modbus数据记录已清除', 'info');
        }
        
        // 请求串口权限
        async function requestSerialPermission() {
            try {
                if (!navigator.serial) {
                    showNotification('浏览器不支持WebSerial API', 'error');
                    return;
                }
                
                const port = await navigator.serial.requestPort();
                showNotification('串口权限获取成功，请点击"刷新串口"查看设备', 'success');
                
                // 自动刷新串口列表
                await refreshSerialPorts();
                
            } catch (error) {
                if (error.name === 'NotFoundError') {
                    showNotification('用户取消了串口选择', 'warning');
                } else {
                    console.error('请求串口权限错误:', error);
                    showNotification(`请求权限失败: ${error.message}`, 'error');
                }
            }
        }
        
        // 绑定Modbus相关事件
        serialRequestPermissionBtn.addEventListener('click', requestSerialPermission);
        serialRefreshBtn.addEventListener('click', refreshSerialPorts);
        serialConnectBtn.addEventListener('click', connectSerialPort);
        serialDisconnectBtn.addEventListener('click', disconnectSerialPort);
        modbusSendBtn.addEventListener('click', sendModbusCommand);
        modbusSendCustomBtn.addEventListener('click', sendCustomModbusFrame);
        modbusClearBtn.addEventListener('click', clearModbusData);
        
        // 初始状态
        updateStatus('准备连接设备...', 'disconnected');
        updateStatus('准备连接串口设备...', 'disconnected', true);
        updateStatus('准备连接DFU设备...', 'disconnected', false, true);
        
        // 确保所有连接按钮初始状态为启用
        connectBtn.disabled = false;
        serialConnectBtn.disabled = false;
        dfuConnectBtn.disabled = false;
        
        // 检查浏览器兼容性
        if (!navigator.serial) {
            showNotification('浏览器不支持WebSerial API，请使用Chrome 89+或Edge 89+', 'error');
            serialPortList.innerHTML = '<div class="serial-port-item" style="color: #ff6b6b;">浏览器不支持WebSerial API<br>请使用Chrome 89+或Edge 89+浏览器</div>';
        } else {
            // 刷新串口列表
            refreshSerialPorts();
        }
        
        // 下一部分将包含DFU功能实现
                // =============================================
        // DFU功能实现
        // =============================================
        
        // DFU协议常量
        const DFU_CLASS = 0xFE;
        const DFU_SUBCLASS = 0x01;
        
        const DFU_REQ_DETACH = 0x00;
        const DFU_REQ_DNLOAD = 0x01;
        const DFU_REQ_UPLOAD = 0x02;
        const DFU_REQ_GETSTATUS = 0x03;
        const DFU_REQ_CLRSTATUS = 0x04;
        const DFU_REQ_GETSTATE = 0x05;
        const DFU_REQ_ABORT = 0x06;
        
        // 检查浏览器是否支持WebUSB
        if (!navigator.usb) {
            dfuStatusText.textContent = "错误：您的浏览器不支持WebUSB API。请使用Chrome 89+或Edge 89+。";
            dfuStatusDot.classList.add('status-disconnected');
            dfuConnectBtn.disabled = true;
            dfuDetectBtn.disabled = true;
        }
        
        // 连接DFU设备
        dfuConnectBtn.addEventListener('click', async () => {
            try {
                showNotification('正在请求DFU设备访问权限...', 'pending');
                updateStatus('正在连接...', 'pending', false, true);
                
                const filters = [
                    { classCode: DFU_CLASS, subclassCode: DFU_SUBCLASS }
                ];
                
                dfuDevice = await navigator.usb.requestDevice({ filters });
                
                if (!dfuDevice) {
                    showNotification('未选择设备', 'warning');
                    updateStatus('未选择设备', 'disconnected', false, true);
                    return;
                }
                
                await dfuDevice.open();
                
                // 更新设备信息
                dfuStatus.textContent = '已连接';
                dfuDeviceName.textContent = dfuDevice.productName || 'DFU设备';
                dfuVendorId.textContent = '0x' + dfuDevice.vendorId.toString(16).toUpperCase();
                dfuProductId.textContent = '0x' + dfuDevice.productId.toString(16).toUpperCase();
                
                // 设置接收数据监听器
                await getDfuStatus();
                
                // 禁用连接按钮
                dfuConnectBtn.disabled = true;
                
                showNotification(`已连接: ${dfuDevice.productName || 'DFU设备'}`, 'success');
                updateStatus('已连接 - 准备就绪', 'connected', false, true);
                
            } catch (error) {
                console.error('DFU连接错误:', error);
                showNotification(`DFU连接失败: ${error.message}`, 'error');
                updateStatus('连接失败', 'disconnected', false, true);
                displayErrorDetails(error, false, true);
                
                if (dfuDevice && dfuDevice.opened) {
                    try {
                        await dfuDevice.close();
                    } catch (e) {
                        console.error('关闭DFU设备错误:', e);
                    }
                }
                
                dfuDevice = null;
                dfuInterface = null;
            }
        });
        
        // 断开DFU设备
        dfuDisconnectBtn.addEventListener('click', async () => {
            if (!dfuDevice) return;
            
            try {
                await dfuDevice.close();
                dfuDevice = null;
                dfuInterface = null;
                
                // 重置设备信息
                dfuStatus.textContent = '未连接';
                dfuDeviceName.textContent = '-';
                dfuVendorId.textContent = '-';
                dfuProductId.textContent = '-';
                
                // 重新启用连接按钮
                dfuConnectBtn.disabled = false;
                
                showNotification('设备已断开', 'info');
                updateStatus('设备已断开', 'disconnected', false, true);
                
            } catch (error) {
                console.error('断开DFU连接错误:', error);
                showNotification(`断开DFU连接失败: ${error.message}`, 'error');
                displayErrorDetails(error, false, true);
            }
        });
        
        // 检测DFU模式
        dfuDetectBtn.addEventListener('click', async () => {
            try {
                showNotification('正在检测DFU设备...', 'pending');
                
                const devices = await navigator.usb.getDevices();
                const dfuDevices = devices.filter(device => {
                    return device.configuration?.interfaces.some(iface => {
                        return iface.alternates.some(alt => 
                            alt.interfaceClass === DFU_CLASS && 
                            alt.interfaceSubclass === DFU_SUBCLASS
                        );
                    });
                });
                
                if (dfuDevices.length > 0) {
                    showNotification(`找到 ${dfuDevices.length} 个DFU设备`, 'success');
                } else {
                    showNotification('未找到DFU设备', 'warning');
                }
                
            } catch (error) {
                console.error('检测DFU设备错误:', error);
                showNotification(`检测DFU设备失败: ${error.message}`, 'error');
            }
        });
        
        // 更新DFU状态显示
        function updateDfuStatus(text, status) {
            dfuStatusText.textContent = text;
            dfuStatusDot.className = 'status-dot';
            
            if (status === 'connected') {
                dfuStatusDot.classList.add('status-connected');
            } else if (status === 'disconnected') {
                dfuStatusDot.classList.add('status-disconnected');
            } else {
                dfuStatusDot.classList.add('status-pending');
            }
        }
        
        // 获取DFU状态
        async function getDfuStatus() {
            if (!dfuDevice) {
                showNotification('错误：DFU设备未连接', 'error');
                return;
            }
            
            try {
                // 查找DFU接口
                dfuInterface = null;
                for (const iface of dfuDevice.configuration.interfaces) {
                    const alternate = iface.alternates.find(a => 
                        a.interfaceClass === DFU_CLASS && 
                        a.interfaceSubclass === DFU_SUBCLASS
                    );
                    
                    if (alternate) {
                        await dfuDevice.claimInterface(iface.interfaceNumber);
                        dfuInterface = iface;
                        break;
                    }
                }
                
                if (!dfuInterface) {
                    throw new Error('未找到DFU接口');
                }
                
                const result = await dfuDevice.controlTransferIn({
                    requestType: 'class',
                    recipient: 'interface',
                    request: DFU_REQ_GETSTATUS,
                    value: 0,
                    index: dfuInterface.interfaceNumber
                }, 6);
                
                if (result.data && result.data.byteLength >= 6) {
                    const status = result.data.getUint8(0);
                    const pollTimeout = result.data.getUint32(1, true) & 0xFFFFFF;
                    const state = result.data.getUint8(4);
                    const statusString = getDfuStatusString(status);
                    const stateString = getDfuStateString(state);
                    
                    dfuState = stateString;
                    
                    dfuReceivedData.textContent = `状态: ${statusString}\n超时: ${pollTimeout}ms\n状态: ${stateString}`;
                    
                    return {
                        status,
                        pollTimeout,
                        state
                    };
                }
                
            } catch (error) {
                console.error('获取DFU状态错误:', error);
                showNotification(`获取DFU状态失败: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // 清除DFU状态
        async function clearDfuStatus() {
            if (!dfuDevice || !dfuInterface) {
                showNotification('错误：DFU设备未连接', 'error');
                return;
            }
            
            try {
                await dfuDevice.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: DFU_REQ_CLRSTATUS,
                    value: 0,
                    index: dfuInterface.interfaceNumber
                });
                
                showNotification('DFU状态已清除', 'success');
                await getDfuStatus();
                
            } catch (error) {
                console.error('清除DFU状态错误:', error);
                showNotification(`清除DFU状态失败: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // 中止DFU操作
        async function abortDfu() {
            if (!dfuDevice || !dfuInterface) {
                showNotification('错误：DFU设备未连接', 'error');
                return;
            }
            
            try {
                await dfuDevice.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: DFU_REQ_ABORT,
                    value: 0,
                    index: dfuInterface.interfaceNumber
                });
                
                showNotification('DFU操作已中止', 'success');
                await getDfuStatus();
                
            } catch (error) {
                console.error('中止DFU操作错误:', error);
                showNotification(`中止DFU操作失败: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // 获取DFU状态字符串
        function getDfuStatusString(status) {
            const statusMap = {
                0x00: 'OK',
                0x01: 'errTARGET',
                0x02: 'errFILE',
                0x03: 'errWRITE',
                0x04: 'errERASE',
                0x05: 'errCHECK_ERASED',
                0x06: 'errPROG',
                0x07: 'errVERIFY',
                0x08: 'errADDRESS',
                0x09: 'errNOTDONE',
                0x0A: 'errFIRMWARE',
                0x0B: 'errVENDOR',
                0x0C: 'errUSBR',
                0x0D: 'errPOR',
                0x0E: 'errUNKNOWN',
                0x0F: 'errSTALLEDPKT'
            };
            
            return statusMap[status] || `未知状态 (0x${status.toString(16)})`;
        }
        
        // 获取DFU状态字符串
        function getDfuStateString(state) {
            const stateMap = {
                0x00: 'appIDLE',
                0x01: 'appDETACH',
                0x02: 'dfuIDLE',
                0x03: 'dfuDNLOAD_SYNC',
                0x04: 'dfuDNBUSY',
                0x05: 'dfuDNLOAD_IDLE',
                0x06: 'dfuMANIFEST_SYNC',
                0x07: 'dfuMANIFEST',
                0x08: 'dfuMANIFEST_WAIT_RESET',
                0x09: 'dfuUPLOAD_IDLE',
                0x0A: 'dfuERROR'
            };
            
            return stateMap[state] || `未知状态 (0x${state.toString(16)})`;
        }
        
        // 处理DFU文件选择
        dfuFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                dfuFile = file;
                dfuFileArrayBuffer = await file.arrayBuffer();
                
                dfuFileInfo.innerHTML = `
                    <div><strong>文件名:</strong> ${file.name}</div>
                    <div><strong>大小:</strong> ${file.size} 字节</div>
                    <div><strong>类型:</strong> ${file.type || '未知'}</div>
                `;
                
                showNotification(`已加载固件文件: ${file.name}`, 'success');
                
            } catch (error) {
                console.error('读取文件错误:', error);
                showNotification(`读取文件失败: ${error.message}`, 'error');
                dfuFile = null;
                dfuFileArrayBuffer = null;
            }
        });
        
        // 上传固件
        dfuUploadBtn.addEventListener('click', async () => {
            if (!dfuDevice || !dfuInterface) {
                showNotification('错误：DFU设备未连接', 'error');
                return;
            }
            
            if (!dfuFile || !dfuFileArrayBuffer) {
                showNotification('错误：未选择固件文件', 'error');
                return;
            }
            
            try {
                showNotification('开始上传固件...', 'pending');
                updateStatus('固件上传中...', 'pending', false, true);
                
                const flashAddress = parseInt(document.getElementById('dfu-flash-address').value, 16) || 0x08000000;
                const eraseType = document.getElementById('dfu-erase-type').value;
                dfuTransferSize = parseInt(document.getElementById('dfu-chunk-size').value) || 1024;
                
                // 设置地址指针
                await setDfuAddress(flashAddress);
                
                // 擦除Flash (如果需要)
                if (eraseType === 'full') {
                    await eraseDfuFull();
                } else if (eraseType === 'sector') {
                    await eraseDfuSectors(flashAddress, dfuFileArrayBuffer.byteLength);
                }
                
                // 分段上传固件
                const totalSize = dfuFileArrayBuffer.byteLength;
                let offset = 0;
                
                while (offset < totalSize) {
                    const chunkSize = Math.min(dfuTransferSize, totalSize - offset);
                    const chunk = new Uint8Array(dfuFileArrayBuffer, offset, chunkSize);
                    
                    await downloadDfuBlock(offset, chunk);
                    
                    offset += chunkSize;
                    dfuProgress = Math.floor((offset / totalSize) * 100);
                    dfuProgressBar.style.width = `${dfuProgress}%`;
                    dfuProgressBar.textContent = `${dfuProgress}%`;
                }
                
                // 完成下载
                await downloadDfuBlock(0, new Uint8Array(0));
                
                showNotification('固件上传完成', 'success');
                updateStatus('固件上传完成', 'connected', false, true);
                
            } catch (error) {
                console.error('上传固件错误:', error);
                showNotification(`上传固件失败: ${error.message}`, 'error');
                updateStatus('上传失败', 'disconnected', false, true);
            }
        });
        
        // 设置DFU地址
        async function setDfuAddress(address) {
            const addressBuffer = new ArrayBuffer(4);
            const addressView = new DataView(addressBuffer);
            addressView.setUint32(0, address, true);
            
            await dfuDevice.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: DFU_REQ_DNLOAD,
                value: 0,
                index: dfuInterface.interfaceNumber
            }, new Uint8Array([0x21, ...new Uint8Array(addressBuffer)]));
            
            await getDfuStatus();
        }
        
        // 全片擦除
        async function eraseDfuFull() {
            await dfuDevice.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: DFU_REQ_DNLOAD,
                value: 0,
                index: dfuInterface.interfaceNumber
            }, new Uint8Array([0x41]));
            
            await getDfuStatus();
            showNotification('Flash全片擦除完成', 'success');
        }
        
        // 按扇区擦除
        async function eraseDfuSectors(startAddress, length) {
            // 这里需要根据具体芯片的扇区分布来实现
            // 简化版: 假设每2KB一个扇区
            const sectorSize = 2048;
            const sectors = Math.ceil(length / sectorSize);
            
            for (let i = 0; i < sectors; i++) {
                const sectorAddress = startAddress + i * sectorSize;
                await setDfuAddress(sectorAddress);
                
                await dfuDevice.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: DFU_REQ_DNLOAD,
                    value: 0,
                    index: dfuInterface.interfaceNumber
                }, new Uint8Array([0x41]));
                
                await getDfuStatus();
            }
            
            showNotification(`已擦除 ${sectors} 个扇区`, 'success');
        }
        
        // 下载DFU块
        async function downloadDfuBlock(blockNumber, data) {
            await dfuDevice.controlTransferOut({
                requestType: 'class',
                recipient: 'interface',
                request: DFU_REQ_DNLOAD,
                value: blockNumber + 2,
                index: dfuInterface.interfaceNumber
            }, data);
            
            await getDfuStatus();
        }
        
        // 验证固件
        dfuVerifyBtn.addEventListener('click', async () => {
            if (!dfuDevice || !dfuInterface) {
                showNotification('错误：DFU设备未连接', 'error');
                return;
            }
            
            try {
                showNotification('开始验证固件...', 'pending');
                updateStatus('验证中...', 'pending', false, true);
                
                // 这里需要根据具体芯片实现验证逻辑
                // 简化版: 读取部分数据验证
                const verifySize = Math.min(1024, dfuFileArrayBuffer.byteLength);
                const flashData = await uploadDfuData(0, verifySize);
                
                const fileData = new Uint8Array(dfuFileArrayBuffer, 0, verifySize);
                const isMatch = compareArrays(flashData, fileData);
                
                if (isMatch) {
                    showNotification('固件验证成功', 'success');
                    updateStatus('验证成功', 'connected', false, true);
                } else {
                    showNotification('固件验证失败: 数据不匹配', 'error');
                    updateStatus('验证失败', 'disconnected', false, true);
                }
                
            } catch (error) {
                console.error('验证固件错误:', error);
                showNotification(`验证固件失败: ${error.message}`, 'error');
                updateStatus('验证失败', 'disconnected', false, true);
            }
        });
        
        // 上传DFU数据 (读取)
        async function uploadDfuData(blockNumber, length) {
            const result = await dfuDevice.controlTransferIn({
                requestType: 'class',
                recipient: 'interface',
                request: DFU_REQ_UPLOAD,
                value: blockNumber,
                index: dfuInterface.interfaceNumber,
                length: length
            });
            
            await getDfuStatus();
            return new Uint8Array(result.data.buffer);
        }
        
        // 比较两个数组
        function compareArrays(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
        
        // 复位设备
        dfuResetBtn.addEventListener('click', async () => {
            if (!dfuDevice || !dfuInterface) {
                showNotification('错误：DFU设备未连接', 'error');
                return;
            }
            
            try {
                await dfuDevice.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: DFU_REQ_DETACH,
                    value: 0,
                    index: dfuInterface.interfaceNumber
                });
                
                showNotification('设备复位命令已发送', 'success');
                updateStatus('等待设备复位...', 'pending', false, true);
                
                // 关闭连接
                await dfuDevice.close();
                dfuDevice = null;
                dfuInterface = null;
                
                // 重置设备信息
                dfuStatus.textContent = '未连接';
                dfuDeviceName.textContent = '-';
                dfuVendorId.textContent = '-';
                dfuProductId.textContent = '-';
                
                updateStatus('设备应已复位', 'disconnected', false, true);
                
            } catch (error) {
                console.error('复位设备错误:', error);
                showNotification(`复位设备失败: ${error.message}`, 'error');
            }
        });
        
        // 绑定DFU命令按钮
        dfuGetStatusBtn.addEventListener('click', getDfuStatus);
        dfuClearStatusBtn.addEventListener('click', clearDfuStatus);
        dfuAbortBtn.addEventListener('click', abortDfu);
        
        // 发送DFU命令
        dfuSendCommandBtn.addEventListener('click', async () => {
            if (!dfuDevice || !dfuInterface) {
                showNotification('错误：DFU设备未连接', 'error');
                return;
            }
            
            try {
                const command = parseInt(document.getElementById('dfu-command').value) || 0;
                const hexData = document.getElementById('dfu-command-data').value;
                const data = hexData.trim() ? hexToBytes(hexData) : new Uint8Array(0);
                
                let result;
                
                if (command === DFU_REQ_UPLOAD) {
                    // 上传命令 (读取)
                    result = await dfuDevice.controlTransferIn({
                        requestType: 'class',
                        recipient: 'interface',
                        request: command,
                        value: 0,
                        index: dfuInterface.interfaceNumber,
                        length: data.length || 64
                    });
                    
                    dfuReceivedData.textContent = `响应数据: ${bytesToHex(new Uint8Array(result.data.buffer))}`;
                    
                } else {
                    // 其他命令 (写入)
                    result = await dfuDevice.controlTransferOut({
                        requestType: 'class',
                        recipient: 'interface',
                        request: command,
                        value: 0,
                        index: dfuInterface.interfaceNumber
                    }, data);
                    
                    dfuReceivedData.textContent = `命令已发送`;
                }
                
                // 获取最新状态
                await getDfuStatus();
                
                showNotification('DFU命令执行成功', 'success');
                
            } catch (error) {
                console.error('发送DFU命令错误:', error);
                showNotification(`发送DFU命令失败: ${error.message}`, 'error');
                dfuReceivedData.textContent = `错误: ${error.message}`;
            }
        });
        
        // 初始化
        updateDfuStatus('准备连接DFU设备...', 'disconnected');
        
        // 页面加载完成
        document.addEventListener('DOMContentLoaded', () => {
            showNotification('页面加载完成，请选择要使用的功能', 'info');
        });
    </script>
</body>
</html>
